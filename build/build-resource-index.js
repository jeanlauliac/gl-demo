#!/usr/bin/env node

'use strict';

const fs = require('fs');
const path = require('path');

const allResourceFilePaths = process.argv.slice(3);
const resources = allResourceFilePaths.map(resourceFilePath => {
  const namespaces = path.dirname(path.relative(
    path.join(__dirname, '../src'),
    resourceFilePath
  )).split(path.sep);
  return {
    namespaces,
    name: path.basename(resourceFilePath).replace('.', '_').toUpperCase(),
  };
});

const indexFilePath = process.argv[2];
const fd = fs.openSync(indexFilePath, 'w');
const currentNamespaces = [];
try {
  fs.writeSync(fd, `// THIS FILE IS AUTOGENERATED, DO NOT MODIFY\n`);
  fs.writeSync(fd, `#pragma once\n`);
  const resourceHeaderPath = path.relative(
    path.dirname(indexFilePath),
    path.resolve(__dirname, '../src/ds/resource.h')
  );
  fs.writeSync(fd, `#include "${resourceHeaderPath}"\n\n`);
  for (let i = 0; i < resources.length; ++i) {
    const res = resources[i];
    let k = 0;
    while (
      k < currentNamespaces.length &&
      k < res.namespaces.length &&
      currentNamespaces[k] === res.namespaces[k]
    ) ++k;
    while (k < currentNamespaces.length) {
      fs.writeSync(fd, '}\n');
      currentNamespaces.pop();
    }
    while (currentNamespaces.length < res.namespaces.length) {
      const ns = res.namespaces[currentNamespaces.length];
      currentNamespaces.push(ns);
      fs.writeSync(fd, `namespace ${ns} {\n`);
    }
    fs.writeSync(fd, `extern const ds::resource ${res.name};\n`);
  }
  while (currentNamespaces.length > 0) {
    fs.writeSync(fd, '}\n');
    currentNamespaces.pop();
  }
} finally {
  fs.closeSync(fd);
}
