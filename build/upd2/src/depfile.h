#pragma once
#include <fstream>
#include <sstream>
#include <vector>

namespace upd {
namespace depfile {

/**
 * We want to read the stream on a character basis, but do some caching to avoid
 * too many I/O calls. We use templating to avoid using virtual functions as
 * much as possible.
 */
template <typename istream_t>
struct istream_char_reader {
  istream_char_reader(istream_t& stream):
    stream_(stream), next_(buffer_), end_(buffer_) {}

  bool next(char& c) {
    if (next_ >= end_) {
      stream_.read(buffer_, sizeof(buffer_));
      end_ = buffer_ + stream_.gcount();
      next_ = buffer_;
    }
    if (next_ >= end_) {
      return false;
    }
    c = *next_;
    ++next_;
    return true;
  }

private:
  istream_t& stream_;
  char* next_;
  char* end_;
  char buffer_[1 << 12];
};

/**
 * Transform a stream of characters into tokens. We have to look one character
 * ahead to know when a token ends. For example a string is ended when we know
 * the next character is space.
 */
template <typename istream_t>
struct tokenizer {
  tokenizer(istream_t& stream): char_reader_(stream) { read_(); }

  template <typename handler_t, typename retval_t>
  retval_t next(handler_t& handler) {
    while (good_ && (c_ == ' ')) read_();
    if (!good_) { return handler.end(); };
    if (c_ == ':') { read_(); return handler.colon(); }
    if (c_ == '\n') { read_(); return handler.new_line(); }
    std::ostringstream oss;
    while (good_ && !(c_ == ' ' || c_ == ':' || c_ == '\n')) {
      if (c_ == '\\') { read_(); }
      oss.put(c_);
      read_();
    }
    auto str = oss.str();
    if (str.size() == 0) {
      throw std::runtime_error("string token of size zero, parser is broken");
    }
    return handler.string(str);
  }

private:
  void read_() {
    read_unescaped_();
    if (!good_ || c_ != '\\') return;
    read_unescaped_();
    if (!good_) {
      throw std::runtime_error("expected character after escape sequence `\\`");
    }
    if (c_ == '\n') {
      c_ = ' ';
    }
  }
  void read_unescaped_() { good_ = char_reader_.next(c_); }
  char c_;
  bool good_;
  istream_char_reader<istream_t> char_reader_;
};

struct depfile_data {
  std::string target_path;
  std::vector<std::string> dependency_paths;
};

struct parse_error {
  parse_error(const std::string& message): message_(message) {}
  std::string message() const { return message_; };
private:
  std::string message_;
};

/**
 * State machine that updates the depfile data for each type of token.
 */
struct parse_token_handler {
  parse_token_handler(std::unique_ptr<depfile_data>& data):
    data_(data), state_(state_t::read_target) {}
  bool end();
  bool colon();
  bool string(const std::string& file_path);
  bool new_line();

private:
  enum class state_t { read_target, read_colon, read_dep, done };
  std::unique_ptr<depfile_data>& data_;
  state_t state_;
};

/**
 * Parse a depfile stream. A 'depfile' is a Makefile-like representation of file
 * dependencies. For example it is generated by the -MF option of gcc or clang,
 * in which case it describes what source and headers a compiled object file
 * depends on. Ex:
 *
 *     foo.o: foo.cpp \
 *       some_header.h \
 *       another_header.h
 *
 * If the stream only has whitespace, this is considered valid but will
 * make it return an empty pointer.
 */
template <typename istream_t>
std::unique_ptr<depfile_data> parse(istream_t& stream) {
  std::unique_ptr<depfile_data> data;
  tokenizer<istream_t> tokens(stream);
  parse_token_handler handler(data);
  while (tokens.template next<parse_token_handler, bool>(handler));
  return data;
}

std::unique_ptr<depfile_data> read(const std::string& depfile_path);

}
}
