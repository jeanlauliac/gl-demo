#include "glob.h"

upd::glob::pattern parse(const std::string& str_pattern) {
  upd::glob::pattern result;
  std::string current_literal;
  for (size_t i = 0; i < str_pattern.size(); ++i) {
    if (str_pattern[i] == '*') {
      result.push_back(std::move(current_literal));
      current_literal.clear();
      continue;
    }
    if (str_pattern[i] == '\\') ++i;
    current_literal += str_pattern[i];
  }
  result.push_back(current_literal);
  return result;
}

@case "parse() convert strings properly" {
  @expect(parse("") == std::vector<std::string>({ "" }));
  @expect(parse("*") == std::vector<std::string>({ "", "" }));
  @expect(parse("foo") == std::vector<std::string>({ "foo" }));
  @expect(parse("foo*bar") == std::vector<std::string>({ "foo", "bar" }));
  @expect(parse("foo*") == std::vector<std::string>({ "foo", "" }));
  @expect(parse("*foo") == std::vector<std::string>({ "", "foo" }));
  @expect(parse("foo\\*bar") == std::vector<std::string>({ "foo*bar" }));
}

@case "upd::glob::match() matches simple literal" {
  @expect(upd::glob::match(parse("foo"), "foo"));
}

@case "upd::glob::match() mismatches longer candidate" {
  @expect(!upd::glob::match(parse("foo"), "foobar"));
}

@case "upd::glob::match() mismatches longer literal" {
  @expect(!upd::glob::match(parse("foobar"), "foo"));
}

@case "upd::glob::match() mismatches empty literal" {
  @expect(!upd::glob::match(parse("foo"), ""));
}

@case "upd::glob::match() mismatches non-matching characters" {
  @expect(!upd::glob::match(parse("foo"), "fob"));
}

@case "upd::glob::match() matches final wildcard, no characters" {
  @expect(upd::glob::match(parse("foo*"), "foo"));
}

@case "upd::glob::match() matches final wildcard, with characters" {
  @expect(upd::glob::match(parse("foo*"), "foobar"));
}

@case "upd::glob::match() matches wildcard, no characters" {
  @expect(upd::glob::match(parse("foo*bar"), "foobar"));
}

@case "upd::glob::match() matches wildcard, with characters" {
  @expect(upd::glob::match(parse("foo*bar"), "foo_beep_bar"));
}

@case "upd::glob::match() mismatches wildcard" {
  @expect(!upd::glob::match(parse("foo*bar"), "foo_beep_boop"));
}

@case "upd::glob::match() mismatches wildcard, no characters" {
  @expect(!upd::glob::match(parse("foo*bar"), "foo"));
}

@case "upd::glob::match() matches starting wildcard, no characters" {
  @expect(upd::glob::match(parse("*bar"), "bar"));
}

@case "upd::glob::match() matches starting wildcard, with characters" {
  @expect(upd::glob::match(parse("*bar"), "foobar"));
}

@case "upd::glob::match() mismatches starting wildcard" {
  @expect(!upd::glob::match(parse("*bar"), "foobarglo"));
}

@case "upd::glob::match() matches several wildcards, no characters" {
  @expect(upd::glob::match(parse("*foo*bar*glo*"), "foobarglo"));
}

@case "upd::glob::match() matches several wildcards, with characters" {
  @expect(upd::glob::match(parse("*foo*bar*glo*"), "__foo_SMTHbar_BEEPglo_BOOP"));
}

@case "upd::glob::match() mismatches several wildcards, with characters" {
  @expect(!upd::glob::match(parse("*foo*bar*glo*"), "__foo_SMTHbar_BEEPgl_BOOP"));
}

@case "upd::glob::match() matches utf8 in wildcard" {
  @expect(upd::glob::match(parse("*.js"), "汉语.js"));
}

@case "upd::glob::match() matches utf8 pattern" {
  @expect(upd::glob::match(parse("汉语*.汉语"), "汉语foo.汉语"));
}

@case "upd::glob::match() matches lone wildcard, no characters" {
  @expect(upd::glob::match(parse("*"), ""));
}

@case "upd::glob::match() matches lone wildcard, with characters" {
  @expect(upd::glob::match(parse("*"), "foobar"));
}
