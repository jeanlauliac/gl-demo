#include "../string_char_reader.h"
#include "lexer.h"

using namespace upd;

struct punctuation_handler {
  punctuation_handler(json::punctuation_type type): type(type) {}

  bool end() const { return false; }
  bool punctuation(json::punctuation_type that_type) const {
    return that_type == type;
  }
  bool string_literal(const std::string&) const { return false; }
  bool number_literal(float) const { return false; }

  json::punctuation_type type;
};

struct string_literal_handler {
  string_literal_handler(const std::string& literal): literal(literal) {}

  bool end() const { return false; }
  bool punctuation(json::punctuation_type) const { return false; }
  bool string_literal(const std::string& that_literal) const { return that_literal == literal; }
  bool number_literal(float) const { return false; }

  std::string literal;
};

struct number_literal_handler {
  number_literal_handler(float literal): literal(literal) {}

  bool end() const { return false; }
  bool punctuation(json::punctuation_type) const { return false; }
  bool string_literal(const std::string& that_literal) const { return false; }
  bool number_literal(float that_literal) const { return that_literal == literal; }

  float literal;
};

struct end_handler {
  bool end() const { return true; }
  bool punctuation(json::punctuation_type) const { return false; }
  bool string_literal(const std::string&) const { return false; }
  bool number_literal(float) const { return false; }
};

template <typename Handler>
bool next(json::lexer<string_char_reader>& lexer, const Handler& handler) {
  return lexer.template next<const Handler, bool>(handler);
}

@case "tokenises single braces" {
  string_char_reader reader("{}\n");
  json::lexer<string_char_reader> lx(reader);
  @expect(next(lx, punctuation_handler(json::punctuation_type::brace_open)));
  @expect(next(lx, punctuation_handler(json::punctuation_type::brace_close)));
  @expect(next(lx, end_handler()));
}

@case "tokenises object" {
  string_char_reader reader("{\"foo\": [\n\"bar\\\"glo\",\n42\n]}\n");
  json::lexer<string_char_reader> lx(reader);
  @expect(next(lx, punctuation_handler(json::punctuation_type::brace_open)));
  @expect(next(lx, string_literal_handler("foo")));
  @expect(next(lx, punctuation_handler(json::punctuation_type::colon)));
  @expect(next(lx, punctuation_handler(json::punctuation_type::bracket_open)));
  @expect(next(lx, string_literal_handler("bar\"glo")));
  @expect(next(lx, punctuation_handler(json::punctuation_type::comma)));
  @expect(next(lx, number_literal_handler(42)));
  @expect(next(lx, punctuation_handler(json::punctuation_type::bracket_close)));
  @expect(next(lx, punctuation_handler(json::punctuation_type::brace_close)));
  @expect(next(lx, end_handler()));
}
