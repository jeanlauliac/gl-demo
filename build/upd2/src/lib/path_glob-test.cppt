#include "glob_test.h"
#include "path_glob.h"
#include <stack>
#include <unordered_map>
#include <unordered_set>

struct mock_ent {
  std::string name;
  int type;
};

static std::unordered_map<std::string, std::vector<mock_ent>>
MOCK_ENTS_BY_DIR_PATH = {
  { "/root", { { .name = "src", .type = DT_DIR } } },
  { "/root/src", {
    { .name = "beep1", .type = DT_DIR },
    { .name = "boop", .type = DT_DIR },
    { .name = "beep2", .type = DT_DIR }
  } },
  { "/root/src/beep1", {
    { .name = "foo.cpp", .type = DT_REG },
    { .name = "subdir.cpp", .type = DT_DIR },
    { .name = "bar.cpp", .type = DT_REG }
  } },
  { "/root/src/beep1/subdir.cpp", { { .name = "smth.cpp", .type = DT_REG } } },
  { "/root/src/boop", {
    { .name = "foo.cpp", .type = DT_REG },
  } },
  { "/root/src/beep2", {
    { .name = "smth.cpp", .type = DT_REG },
  } },
};

struct mock_dir_reader {
  mock_dir_reader(): is_open_(false) {}

  bool is_open() { return is_open_; }

  dirent* next() {
    if (!is_open_) {
      throw std::runtime_error("dir reader is not open");
    }
    const auto& mock_ents = MOCK_ENTS_BY_DIR_PATH.at(dir_path_);
    if (ent_ix_ >= mock_ents.size()) {
      return nullptr;
    }
    const auto& ent = mock_ents[ent_ix_++];
    current_dirent_.d_ino = 42;
    current_dirent_.d_reclen = sizeof(dirent);
    current_dirent_.d_type = ent.type;
    strcpy(current_dirent_.d_name, ent.name.c_str());
    return &current_dirent_;
  }

  void open(const std::string dir_path) {
    dir_path_ = dir_path;
    ent_ix_ = 0;
    is_open_ = true;
  }

  void close() { is_open_ = false; }

private:
  bool is_open_;
  std::string dir_path_;
  size_t ent_ix_;
  dirent current_dirent_;
};

using namespace upd::path_glob;

enum class invalid_pattern_string_reason {
  duplicate_directory_wildcard,
  duplicate_wildcard,
  escape_char_at_end,
  unexpected_capture_close,
};

struct invalid_pattern_string_error {
  invalid_pattern_string_error(invalid_pattern_string_reason reason):
    reason(reason) {};

  invalid_pattern_string_reason reason;
};

struct pattern_string_parser {
  pattern_string_parser(const std::string& input):
    input(input) {}

  pattern operator()() {
    input_ix = 0;
    result.segments.clear();
    current_segment.clear();
    read_path_segment();
    while (!current_segment.ent_name.empty()) {
      result.segments.push_back(current_segment);
      read_path_segment();
    }
    return result;
  }

  void read_path_segment() {
    current_segment.ent_name.clear();
    current_segment.has_wildcard = read_directory_wildcard();
    if (read_directory_wildcard()) {
      throw invalid_pattern_string_error(invalid_pattern_string_reason::duplicate_directory_wildcard);
    }
    while (input_ix < input.size() && input[input_ix] != '/') {
      process_input_char();
      ++input_ix;
    }
    finish_glob_segment();
    if (input_ix < input.size()) ++input_ix;
  }

  void process_input_char() {
    if (input[input_ix] == '*') {
      if (
        current_glob_segment.prefix == upd::glob::placeholder::wildcard &&
        current_glob_segment.literal.empty()
      ) {
        throw invalid_pattern_string_error(invalid_pattern_string_reason::duplicate_wildcard);
      }
      finish_glob_segment();
      current_glob_segment.prefix = upd::glob::placeholder::wildcard;
      return;
    }
    if (input[input_ix] == '?') {
      finish_glob_segment();
      current_glob_segment.prefix = upd::glob::placeholder::single_wildcard;
      return;
    }
    if (input[input_ix] == '(') {
      open_capture_group_in_name();
      return;
    }
    if (input[input_ix] == ')') {
      close_capture_group();
      return;
    }
    if (input[input_ix] == '\\') ++input_ix;
    if (input_ix == input.size()) {
      throw invalid_pattern_string_error(invalid_pattern_string_reason::escape_char_at_end);
    }
    current_glob_segment.literal += input[input_ix];
  }

  void open_capture_group_in_name() {
    finish_glob_segment();
    open_capture_group({
      .type = capture_point_type::ent_name,
      .ent_name_segment_ix = current_segment.ent_name.size(),
      .segment_ix = result.segments.size(),
    });
  }

  void close_capture_group() {
    finish_glob_segment();
    if (capture_groups_ids.empty()) {
      throw invalid_pattern_string_error(invalid_pattern_string_reason::unexpected_capture_close);
    }
    auto& group = result.capture_groups[capture_groups_ids.top()];
    capture_groups_ids.pop();
    group.to = {
      .type = capture_point_type::ent_name,
      .ent_name_segment_ix = current_segment.ent_name.size(),
      .segment_ix = result.segments.size(),
    };
  }

  void finish_glob_segment() {
    if (current_glob_segment.empty()) return;
    current_segment.ent_name.push_back(std::move(current_glob_segment));
    current_glob_segment.clear();
  }

  bool read_directory_wildcard() {
    bool open_capture = false, close_capture = false;
    size_t ix = input_ix;
    if (ix >= input.size()) return false;
    if (input[ix] == '(') {
      open_capture = true;
      ++ix;
    }
    if (ix + 2 >= input.size()) return false;
    if (input[ix] != '*' || input[ix + 1] != '*') return false;
    ix += 2;
    if (ix + 1 >= input.size()) return false;
    if (input[ix] == ')') {
      close_capture = true;
      ++ix;
    }
    if (ix >= input.size()) return false;
    if (input[ix] != '/') return false;
    input_ix = ix + 1;
    if (open_capture) {
      open_capture_group({
        .type = capture_point_type::wildcard,
        .segment_ix = result.segments.size(),
      });
    }
    if (close_capture) {
      throw std::runtime_error("not implemented!");
    }
    return true;
  }

  void open_capture_group(const capture_point& from) {
    result.capture_groups.push_back(capture_group({ .from = from }));
    capture_groups_ids.push(result.capture_groups.size() - 1);
  }

  const std::string& input;
  size_t input_ix;
  segment current_segment;
  upd::glob::segment current_glob_segment;
  pattern result;
  std::stack<size_t> capture_groups_ids;
};

pattern parse_pattern_string(const std::string& pattern_string) {
  return pattern_string_parser(pattern_string)();
}

@case "pattern_string_parser works" {
  @expect(parse_pattern_string("foo/**/beep/*.js") == pattern({
    .capture_groups = {},
    .segments = {
      upd::path_glob::segment { .ent_name = parse("foo"), .has_wildcard = false },
      upd::path_glob::segment { .ent_name = parse("beep"), .has_wildcard = true },
      upd::path_glob::segment { .ent_name = parse("*.js"), .has_wildcard = false },
    }
  }));
}

@case "pattern_string_parser works with capture" {
  @expect(parse_pattern_string("foo/(**/beep/*).js") == pattern({
    .capture_groups = { {
      .from = {
        .type = capture_point_type::wildcard,
        .segment_ix = 1,
      },
      .to = {
        .type = capture_point_type::ent_name,
        .segment_ix = 2,
        .ent_name_segment_ix = 1,
      },
    } },
    .segments = {
      upd::path_glob::segment { .ent_name = parse("foo"), .has_wildcard = false },
      upd::path_glob::segment { .ent_name = parse("beep"), .has_wildcard = true },
      upd::path_glob::segment { .ent_name = upd::glob::pattern({
        upd::glob::segment(upd::glob::placeholder::wildcard),
        upd::glob::segment(".js")
      }), .has_wildcard = false },
    }
  }));
}

@case "find files" {
  auto pattern = parse_pattern_string("src/beep*/*.cpp");
  upd::path_glob::matcher<mock_dir_reader> mtcr("/root", pattern);
  upd::path_glob::match mt;
  std::unordered_set<std::string> mts;
  while (mtcr.next(mt)) mts.insert(mt.local_path);
  std::unordered_set<std::string> expected =
    { "src/beep1/foo.cpp", "src/beep1/bar.cpp", "src/beep2/smth.cpp" };
  @expect(mts == expected);
}

@case "find files with folder wildcard" {
  auto pattern = parse_pattern_string("src/**/*.cpp");
  upd::path_glob::matcher<mock_dir_reader> mtcr("/root", pattern);
  upd::path_glob::match mt;
  std::unordered_set<std::string> mts;
  while (mtcr.next(mt)) mts.insert(mt.local_path);
  std::unordered_set<std::string> expected = {
    "src/beep1/foo.cpp",
    "src/beep1/bar.cpp",
    "src/beep1/subdir.cpp/smth.cpp",
    "src/beep2/smth.cpp",
    "src/boop/foo.cpp"
  };
  @expect(mts == expected);
}

typedef std::vector<std::pair<size_t, size_t>> captures;
typedef std::unordered_map<std::string, captures> matches;

@case "find and capture files" {
  auto pattern = parse_pattern_string("src/(**/*).cpp");
  upd::path_glob::matcher<mock_dir_reader> mtcr("/root", pattern);
  upd::path_glob::match mt;
  matches mts;
  while (mtcr.next(mt)) mts[mt.local_path] = mt.captured_groups;
  matches expected = {
    { "src/beep1/foo.cpp", { { 4, 13, } } },
    { "src/beep1/bar.cpp", { { 4, 13 } } },
    { "src/beep1/subdir.cpp/smth.cpp", { { 4, 25 } } },
    { "src/beep2/smth.cpp", { { 4, 14 } } },
    { "src/boop/foo.cpp", { { 4, 12 } } },
  };
  @expect(mts == expected);
}
