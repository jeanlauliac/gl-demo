#include "glob_test.h"
#include "path_glob.h"
#include <unordered_map>
#include <unordered_set>

struct mock_ent {
  std::string name;
  int type;
};

static std::unordered_map<std::string, std::vector<mock_ent>>
MOCK_ENTS_BY_DIR_PATH = {
  { "/root", { { .name = "src", .type = DT_DIR } } },
  { "/root/src", {
    { .name = "beep1", .type = DT_DIR },
    { .name = "boop", .type = DT_DIR },
    { .name = "beep2", .type = DT_DIR }
  } },
  { "/root/src/beep1", {
    { .name = "foo.cpp", .type = DT_REG },
    { .name = "subdir.cpp", .type = DT_DIR },
    { .name = "bar.cpp", .type = DT_REG }
  } },
  { "/root/src/beep1/subdir.cpp", { { .name = "smth.cpp", .type = DT_REG } } },
  { "/root/src/boop", {
    { .name = "foo.cpp", .type = DT_REG },
  } },
  { "/root/src/beep2", {
    { .name = "smth.cpp", .type = DT_REG },
  } },
};

struct mock_dir_reader {
  mock_dir_reader(): is_open_(false) {}

  bool is_open() { return is_open_; }

  dirent* next() {
    if (!is_open_) {
      throw std::runtime_error("dir reader is not open");
    }
    const auto& mock_ents = MOCK_ENTS_BY_DIR_PATH.at(dir_path_);
    if (ent_ix_ >= mock_ents.size()) {
      return nullptr;
    }
    const auto& ent = mock_ents[ent_ix_++];
    current_dirent_.d_ino = 42;
    current_dirent_.d_reclen = sizeof(dirent);
    current_dirent_.d_type = ent.type;
    strcpy(current_dirent_.d_name, ent.name.c_str());
    return &current_dirent_;
  }

  void open(const std::string dir_path) {
    dir_path_ = dir_path;
    ent_ix_ = 0;
    is_open_ = true;
  }

  void close() { is_open_ = false; }

private:
  bool is_open_;
  std::string dir_path_;
  size_t ent_ix_;
  dirent current_dirent_;
};

@case "find files" {
  upd::path_glob::matcher<mock_dir_reader> mtcr("/root", {
    .segments = {
      upd::path_glob::segment { .ent_name = parse("src"), .has_wildcard = false },
      upd::path_glob::segment { .ent_name = parse("beep*"), .has_wildcard = false },
      upd::path_glob::segment { .ent_name = parse("*.cpp"), .has_wildcard = false }
    }
  });
  upd::path_glob::match mt;
  std::unordered_set<std::string> mts;
  while (mtcr.next(mt)) mts.insert(mt.local_path);
  std::unordered_set<std::string> expected =
    { "src/beep1/foo.cpp", "src/beep1/bar.cpp", "src/beep2/smth.cpp" };
  @expect(mts == expected);
}

@case "find files with folder wildcard" {
  upd::path_glob::matcher<mock_dir_reader> mtcr("/root", {
    .segments = {
      upd::path_glob::segment { .ent_name = parse("src"), .has_wildcard = false },
      upd::path_glob::segment { .ent_name = parse("*.cpp"), .has_wildcard = true }
    }
  });
  upd::path_glob::match mt;
  std::unordered_set<std::string> mts;
  while (mtcr.next(mt)) mts.insert(mt.local_path);
  std::unordered_set<std::string> expected = {
    "src/beep1/foo.cpp",
    "src/beep1/bar.cpp",
    "src/beep1/subdir.cpp/smth.cpp",
    "src/beep2/smth.cpp",
    "src/boop/foo.cpp"
  };
  @expect(mts == expected);
}
