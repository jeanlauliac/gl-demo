#include "glob_test.h"
#include "path_glob.h"
#include <unordered_map>
#include <unordered_set>

struct mock_ent {
  std::string name;
  int type;
};

static std::unordered_map<std::string, std::vector<mock_ent>>
MOCK_ENTS_BY_DIR_PATH = {
  { "/root", { { .name = "src", .type = DT_DIR } } },
  { "/root/src", {
    { .name = "beep1", .type = DT_DIR },
    { .name = "boop", .type = DT_DIR },
    { .name = "beep2", .type = DT_DIR }
  } },
  { "/root/src/beep1", {
    { .name = "foo.cpp", .type = DT_REG },
    { .name = "subdir.cpp", .type = DT_DIR },
    { .name = "bar.cpp", .type = DT_REG }
  } },
  { "/root/src/beep1/subdir.cpp", { { .name = "smth.cpp", .type = DT_REG } } },
  { "/root/src/boop", {
    { .name = "foo.cpp", .type = DT_REG },
  } },
  { "/root/src/beep2", {
    { .name = "smth.cpp", .type = DT_REG },
  } },
};

struct mock_dir_reader {
  mock_dir_reader(): is_open_(false) {}

  bool is_open() { return is_open_; }

  dirent* next() {
    if (!is_open_) {
      throw std::runtime_error("dir reader is not open");
    }
    const auto& mock_ents = MOCK_ENTS_BY_DIR_PATH.at(dir_path_);
    if (ent_ix_ >= mock_ents.size()) {
      return nullptr;
    }
    const auto& ent = mock_ents[ent_ix_++];
    current_dirent_.d_ino = 42;
    current_dirent_.d_reclen = sizeof(dirent);
    current_dirent_.d_type = ent.type;
    strcpy(current_dirent_.d_name, ent.name.c_str());
    return &current_dirent_;
  }

  void open(const std::string dir_path) {
    dir_path_ = dir_path;
    ent_ix_ = 0;
    is_open_ = true;
  }

  void close() { is_open_ = false; }

private:
  bool is_open_;
  std::string dir_path_;
  size_t ent_ix_;
  dirent current_dirent_;
};

using namespace upd::path_glob;

enum class invalid_pattern_string_reason {
  double_wildcard,
  escape_char_at_end,
};

struct invalid_pattern_string_error {
  invalid_pattern_string_error(invalid_pattern_string_reason reason):
    reason(reason) {};

  invalid_pattern_string_reason reason;
};

struct pattern_string_parser {
  pattern_string_parser(const std::string& input):
    input(input) {}

  pattern operator()() {
    input_ix = 0;
    result.segments.clear();
    current_segment.clear();
    read_path_segment();
    while (!current_segment.ent_name.empty()) {
      result.segments.push_back(current_segment);
      read_path_segment();
    }
    return result;
  }

  void read_path_segment() {
    current_segment.ent_name.clear();
    current_segment.has_wildcard = read_wildcard();
    if (read_wildcard()) {
      throw invalid_pattern_string_error(invalid_pattern_string_reason::double_wildcard);
    }
    while (input_ix < input.size() && input[input_ix] != '/') {
      process_input_char();
      ++input_ix;
    }
    finish_glob_segment();
    if (input_ix < input.size()) ++input_ix;
  }

  void process_input_char() {
    if (input[input_ix] == '*') {
      finish_glob_segment();
      current_glob_segment.prefix = upd::glob::placeholder::wildcard;
      return;
    }
    if (input[input_ix] == '?') {
      finish_glob_segment();
      current_glob_segment.prefix = upd::glob::placeholder::single_wildcard;
      return;
    }
    if (input[input_ix] == ')' || input[input_ix] == '(') {
      finish_glob_segment();
      return;
    }
    if (input[input_ix] == '\\') ++input_ix;
    if (input_ix == input.size()) {
      throw invalid_pattern_string_error(invalid_pattern_string_reason::escape_char_at_end);
    }
    current_glob_segment.literal += input[input_ix];
  }

  void finish_glob_segment() {
    if (current_glob_segment.empty()) return;
    current_segment.ent_name.push_back(std::move(current_glob_segment));
    current_glob_segment.clear();
  }

  bool read_wildcard() {
    if (input.size() - input_ix < 3) return false;
    if (input[input_ix] != '*' && input[input_ix + 1] != '*') return false;
    if (input[input_ix + 2] != '/') return false;
    input_ix += 3;
    return true;
  }

  const std::string& input;
  size_t input_ix;
  segment current_segment;
  upd::glob::segment current_glob_segment;
  pattern result;
};

pattern parse_pattern_string(const std::string& pattern_string) {
  return pattern_string_parser(pattern_string)();
}

@case "pattern_string_parser works" {
  @expect(parse_pattern_string("foo/**/beep/*.js") == pattern({
    .segments = {
      upd::path_glob::segment { .ent_name = parse("foo"), .has_wildcard = false },
      upd::path_glob::segment { .ent_name = parse("beep"), .has_wildcard = true },
      upd::path_glob::segment { .ent_name = parse("*.js"), .has_wildcard = false },
    }
  }));
}

@case "pattern_string_parser works with capture" {
  @expect(parse_pattern_string("foo/**/beep/*).js") == pattern({
    .segments = {
      upd::path_glob::segment { .ent_name = parse("foo"), .has_wildcard = false },
      upd::path_glob::segment { .ent_name = parse("beep"), .has_wildcard = true },
      upd::path_glob::segment { .ent_name = upd::glob::pattern({
        upd::glob::segment(upd::glob::placeholder::single_wildcard),
        upd::glob::segment(".js")
      }), .has_wildcard = false },
    }
  }));
}

@case "find files" {
  auto pattern = parse_pattern_string("src/beep*/*.cpp");
  upd::path_glob::matcher<mock_dir_reader> mtcr("/root", pattern);
  upd::path_glob::match mt;
  std::unordered_set<std::string> mts;
  while (mtcr.next(mt)) mts.insert(mt.local_path);
  std::unordered_set<std::string> expected =
    { "src/beep1/foo.cpp", "src/beep1/bar.cpp", "src/beep2/smth.cpp" };
  @expect(mts == expected);
}

@case "find files with folder wildcard" {
  auto pattern = parse_pattern_string("src/**/*.cpp");
  upd::path_glob::matcher<mock_dir_reader> mtcr("/root", pattern);
  upd::path_glob::match mt;
  std::unordered_set<std::string> mts;
  while (mtcr.next(mt)) mts.insert(mt.local_path);
  std::unordered_set<std::string> expected = {
    "src/beep1/foo.cpp",
    "src/beep1/bar.cpp",
    "src/beep1/subdir.cpp/smth.cpp",
    "src/beep2/smth.cpp",
    "src/boop/foo.cpp"
  };
  @expect(mts == expected);
}
