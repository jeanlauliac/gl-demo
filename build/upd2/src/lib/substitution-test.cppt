#include "substitution.h"

using namespace upd::substitution;

@case "segment() is empty by default" {
  segment s;
  @expect(s.empty());
}

@case "segment() constructs from literal" {
  segment s("foo");
  @expect(!s.empty());
  @expect(s.literal == "foo");
  @expect(!s.has_captured_group);
}

@case "segment() constructs from literal and captured group index" {
  segment s(42, "foo");
  @expect(!s.empty());
  @expect(s.literal == "foo");
  @expect(s.has_captured_group);
  @expect(s.captured_group_ix == 42);
}

@case "segment() is empty after clear()" {
  segment s(42, "foo");
  s.clear();
  @expect(s.empty());
}

@case "parse() parses empty string" {
  auto result = parse("");
  @expect(result == pattern({ .segments = {}, .capture_groups = {} }));
}

@case "parse() parses single literal" {
  auto result = parse("foobar");
  @expect(result == pattern({ .segments = {
    segment("foobar"),
  }, .capture_groups = {} }));
}

@case "parse() parses literal with captured group indices" {
  auto result = parse("foo$1bar$2");
  @expect(result == pattern({ .segments = {
    segment("foo"),
    segment(0, "bar"),
    segment(1),
  }, .capture_groups = {} }));
}

@case "parse() escapes captured group character" {
  auto result = parse("foo\\$1bar");
  @expect(result == pattern({ .segments = {
    segment("foo$1bar"),
  }, .capture_groups = {} }));
}

@case "parse() allows to capture literal" {
  auto result = parse("foo(bar)");
  @expect(result == pattern({ .segments = {
    segment("foo"),
    segment("bar"),
  }, .capture_groups = { { 1, 2 } } }));
}

@case "parse() allows to recapture captured groups" {
  auto result = parse("foo($1)bar");
  @expect(result == pattern({ .segments = {
    segment("foo"),
    segment(0),
    segment("bar"),
  }, .capture_groups = { { 1, 2 } } }));
}
